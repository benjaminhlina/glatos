% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interpolatePath.r
\name{interpolatePath}
\alias{interpolatePath}
\title{Interpolate new positions within a spatiotemporal path data}
\usage{
interpolatePath(dtc, trans = NULL, int_time_stamp = 86400,
  lnl_thresh = 0.9)
}
\arguments{
\item{dtc}{An object of class \code{glatos_detections} or data frame
containing spatiotemporal data with at least 4 columns containing
'animal_id', 'detection_timestamp_utc','deploy_long', and
'deploy_lat' columns.}

\item{trans}{An optional transition matrix with the "cost" of
moving across each cell within the map extent. Must be of class
\code{TransitionLayer} (See \code{gdistance} package).}

\item{int_time_stamp}{The time step size (in seconds) of interpolated 
positions. Default is 86400 (one day).}

\item{lnl_thresh}{A numeric threshold for determining if linear or
non-linear interpolation shortest path will be used.}
}
\value{
A dataframe with animal_id, bin_timestamp,
  latitude, longitude, and record_type.
}
\description{
Interpolate new positions within a spatiotemporal path data set 
  (e.g., detections of tagged fish) at regularly-spaced time intervals   
	 using linear or non-linear interpolation.
}
\details{
Non-linear interpolation uses the 'gdistance' package to
  find the shortest pathway between two locations (i.e., receivers)
  that avoid 'impossible' movements (e.g., over land for fish). The
  shortest non-linear path between two locations is calculated
  using a 'transition matrix layer' (\code{trans}) that represents
  the 'cost' of an animal moving between adjacent grid cells.  For
  example, each cell in \code{rast} may be coded as water (1) or
  land (0) to represent possible (1) and impossible (0) movement
  paths.

Linear interpolation is used for all points when
  \code{trans} is not supplied.  When \code{trans} is supplied,
  then interpolation method is determined for each pair of observed
  positions. For example, linear interpolation will be used if the
  two points are exactly the same and when the ratio (linear
  distance:non-linear distance) between two positions is less than
  \code{lnl_thresh}.  Non-linear interpolation will be used when
  ratio is greater than \code{lnl_thresh}.  \code{lnl_thresh} can
  be used to control whether non-linear or linear interpolation is
  used for all points. For example, non-linear interpolation will
  be used for all points when \code{lnl_thresh} = 1 and linear
  interpolation will be used for all points when \code{lnl_thresh}
  = 0.
}
\examples{

-------------------------------------------------------
# EXAMPLE #1 - simple example
  
# example map background
data(greatLakesPoly)
library(sp) #to plot SpatialPolygon without error
plot(greatLakesPoly)

# make up points
pos <- data.frame(
   animal_id=1,
   deploy_long=c(-87,-82.5, -78),
   deploy_lat=c(44, 44.5, 43.5),
   detection_timestamp_utc=as.POSIXct(c("2000-01-01 00:00",
     "2000-02-01 00:00", "2000-03-01 00:00"), tz = "UTC"))

# coerce to SpatialPoints object and plot
 pts <- SpatialPoints(pos[,c("deploy_long","deploy_lat")])
 points(pts, pch=20, col='red', cex=3)

# interpolate path using linear method
path1 <- interpolatePath(pos)
 
# coerce to SpatialPoints object and plot
pts1 <- SpatialPoints(path1[,c("longitude","latitude")])
points(pts1, pch=20, col='blue', lwd=2, cex=1.5) 

# example transition matrix
data(greatLakesTrLayer)
 
# interpolate path using non-linear method (requires 'trans')
path2 <- interpolatePath(pos, trans=greatLakesTrLayer)

# coerce to SpatialPoints object and plot
pts2 <- SpatialPoints(path2[,c("longitude","latitude")])
points(pts2, pch=20, col='green', lwd=2, cex=1.5) 
 
# can also force linear-interpolation with lnlThresh=0
path3 <- interpolatePath(pos, trans=greatLakesTrLayer, lnl_thresh=0)

# coerce to SpatialPoints object and plot
pts3 <- SpatialPoints(path3[,c("longitude","latitude")])
points(pts3, pch=20, col='magenta', lwd=2, cex=1.5) 
--------------------------------------------------
# EXAMPLE #2 - GLATOS detection data

# load detection data
det_file <- system.file("extdata", "walleye_detections.zip", package = "glatos")
det_file <- unzip(det_file, "walleye_detections.csv")
dtc <- read_glatos_detections(det_file)

# take a look
head(dtc)
 
# call with defaults; linear interpolation
pos1 <- interpolatePath(dtc)
 
# plot on example map background
data(greatLakesPoly)
library(sp) # to plot SpatialPolygon without error
plot(greatLakesPoly)
 
# coerce to SpatialPoints object and plot
pts1 <- SpatialPoints(pos1[, c("longitude", "latitude")])
points(pts1, pch=20, col='red', cex=0.5)
 
# example transition matrix
data(greatLakesTrLayer)
 
# call with "transition matrix" (non-linear interpolation), other options
# note that it is quite a bit slower due than linear interpolation
pos2 <- interpolatePath(dtc, trans=greatLakesTrLayer)

# coerce to SpatialPoints object and plot
pts2 <- SpatialPoints(pos2[, c("longitude","latitude")])
points(pts2, pch=20, col='blue', cex=0.5)

}
\author{
Todd Hayden, Tom Binder, Chris Holbrook
}
